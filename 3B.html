
<!DOCTYPE html>

<html>

<head>
    <title>3B</title>
    <script type="text/javascript" src="..\libs\three.js"></script>
    <script type="text/javascript" src="..\libs\jquery-1.9.0.js"></script>
    <script type="text/javascript" src="..\libs\stats.js"></script>
	<script type="text/javascript" src="..\libs\dat.gui.js"></script>
	<script type="text/javascript" src="..\libs\TrackballControls.js"></script>
    <style>
        body{
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output"> </div>

<!-- Div which will hold the Output -->
<div id="WebGL-output"> </div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    $(function () {
	
		var clock = new THREE.Clock();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();
		
		var axes = new THREE.AxisHelper( 20 );
        //scene.add(axes);

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
		// position and point the camera to the center of the scene
        camera.position.x = -150;
        camera.position.y = 100;
        camera.position.z = 40;
        camera.lookAt(scene.position);
		scene.add(camera);
		var helper = new THREE.CameraHelper( camera );
		//scene.add( helper );
		
		var camera2 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 650);
		camera2.position.x = -40;
        camera2.position.y = 6;
        camera2.position.z = 0;
        //camera2.lookAt(scene.position);
		camera2.lookAt(new THREE.Vector3(0, 6, 0));
		scene.add(camera2);
		var helper2 = new THREE.CameraHelper( camera2 );
		helper2.visible = false;
		scene.add( helper2 );
		
		// create a render and set the size
        var renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x333333, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;
		// add the output of the renderer to the html element
        $("#WebGL-output").append(renderer.domElement);


		var Xpoz = 0;
		var Ypoz = -5;
		var p_x = 0;
		var p_y = 0;
		var p_z = -18;
		var white = 0;

		var board = new THREE.Object3D();

		for(i = 0; i < 8; i++){
			for(j = 0; j < 8; j++){
			
				var cubeGeometry = new THREE.CubeGeometry(18,18,4);
				var cubeMaterialBlack = new THREE.MeshLambertMaterial({color: 0x101010});
				var cubeMaterialWhite = new THREE.MeshLambertMaterial({color: 0xffffff});
				//var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
			
				if(white == 1){
					var cube = new THREE.Mesh(cubeGeometry,cubeMaterialWhite);
					white = 0;
				}
				else if(white == 0) {
					var cube = new THREE.Mesh(cubeGeometry,cubeMaterialBlack);
					white = 1;
				}
				cube.castShadow  = true;
				cube.receiveShadow = true;
				cube.position.x=p_x;
				cube.position.y=p_y;
				cube.position.z=p_z;
				p_x += 18;
				board.add(cube);
				
			}
			p_x=0;
			p_y+=18;
			if(white == 1){
				white = 0;
			}
			else {
				white = 1;
			}
		}
		board.rotation.x=-0.5*Math.PI;
		board.position.x=-8*18/2-18
		board.rotation.z = -0.25*Math.PI;
        board.position.y=0
        board.position.z=0
		scene.add(board);








		
		// add spotlight for the shadows
        var spotLight = new THREE.SpotLight( 0xffffff );
        spotLight.position.set( -200, 200, -10 );
        spotLight.castShadow = true;
        scene.add( spotLight );
		var spotLightHelper = new THREE.SpotLightHelper( spotLight );
		//scene.add( spotLightHelper );
		
		// add pointlight 
		var light = new THREE.PointLight( 0xbcaea7, 1, 100 );
		light.position.set( -10, 15, 5 );
		//light.castShadow = true;
		scene.add( light );
		var pointLightHelper = new THREE.PointLightHelper( light, 1 );
		//scene.add(pointLightHelper);
		
		var trackballControls = new THREE.TrackballControls(camera, renderer.domElement);
		trackballControls.rotateSpeed = 1.0;
        trackballControls.zoomSpeed = 1.0;
        trackballControls.panSpeed = 1.0;
		//trackballControls.noZoom=false;
		//trackballControls.noPan=false;
        trackballControls.staticMoving = true;
		//trackballControls.dynamicDampingFactor=0.3;
	
		/////////////////////////////////////////////
		///..........................................

		


	bishop(60, Xpoz*18, Ypoz*18, 0xffffff);
	
		
	function bishop(segments, m_x, m_z, color) {




		var pointsX = [
		250, 260, 275, 290, 295,
		 295, 290, 280, 285, 290,
		 290, 285, 300, 300, 280,
		 280, 280, 285, 290, 295,
		 300, 305, 310, 325, 335,
		 335, 325, 335, 335, 250 ];
	var pointsY = [
	 60, 65, 90, 115, 135,
	 150, 161, 171, 181, 186,
	 196, 206, 211, 226, 226,
	 236, 251, 266, 276, 291,
	 301, 311, 321, 326, 336,
	 351, 361, 366, 411, 411];
	// add 10 random spheres
		var points = [];
		var height = 2;
		var count = 30;
		for (var i = 0; i < count; i++) {
			points.push(new THREE.Vector3(25-pointsX[i]/10, 0, (1-pointsY[i])/10));
		}

		var latheGeometry = new THREE.LatheGeometry(points, Math.ceil(segments), 0, 3 * Math.PI);
		bishop1 = createMesh(latheGeometry, color);
		
		//bishop1.rotation.x = -0.5*Math.PI;
		bishop1.rotation.x = -0.5*Math.PI;
		bishop1.position.x = m_x;
		bishop1.position.y = 25;

		bishop1.position.z = m_z;

		//var axis = new THREE.Vector3(0,0,0);
		//latheMesh.rotateOnAxis(axis, Math.PI/2);
		scene.add(bishop1);
	}

	function createMesh(geom, col) {

		// assign two materials
		//  var meshMaterial = new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.6});
		var meshMaterial = new THREE.MeshLambertMaterial({color: col, transparent:false});
		meshMaterial.side = THREE.DoubleSide;
		//var wireFrameMat = new THREE.MeshBasicMaterial();
		//wireFrameMat.wireframe = true;

		// create a multimaterial
		//var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]);

		var mesh = new THREE.Mesh(geom, meshMaterial);
		mesh.castShadow = true;
		
		
		return mesh;
	}



		/////////////////////////////////////////////
		
		  camera1Group = new THREE.Object3D();
		camera1Box = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 4), new THREE.MeshLambertMaterial({color: 0x666666}));
		 camera1Group.add(camera1Box);
		camera1Box.position.set(0, 0.5, -2.5);
		//scene.add(camera1Box);
		
		camera1Cylinder1 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 1), new THREE.MeshLambertMaterial({color: 0x666666}));
		 camera1Group.add(camera1Cylinder1);
		camera1Cylinder1.rotation.z = Math.PI/2;
		camera1Cylinder1.position.set(0, 1.5, -1.5);
		//scene.add(camera1Cylinder1);
		
		camera1Cylinder2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 1), new THREE.MeshLambertMaterial({color: 0x666666}));
		 camera1Group.add(camera1Cylinder2);
		camera1Cylinder2.rotation.z = Math.PI/2;
		camera1Cylinder2.position.set(0, 1.5, -3.5);
		//scene.add(camera1Cylinder2);
		
		camera1Cylinder3 = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.5, 1), new THREE.MeshLambertMaterial({color: 0x777777}));
		 camera1Group.add(camera1Cylinder3);
		camera1Cylinder3.rotation.x = Math.PI/2;
		camera1Cylinder3.position.set(0, 0, 0);
		//scene.add(camera1Cylinder3);
		
		camera1Group.position.set(-40, 6, 0);
		//camera1Group.lookAt(scene.position);
		camera1Group.lookAt(new THREE.Vector3(0, 6, 0));
		scene.add(camera1Group);
		
		/////////////////////////////////////////////
		
		  camera2Group = new THREE.Object3D();
		camera2Box = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 4), new THREE.MeshLambertMaterial({color: 0x666666}));
		 camera2Group.add(camera2Box);
		camera2Box.position.set(0, 0.5, -2.5);
		//scene.add(camera2Box);
		
		camera2Cylinder1 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 1), new THREE.MeshLambertMaterial({color: 0x666666}));
		 camera2Group.add(camera2Cylinder1);
		camera2Cylinder1.rotation.z = Math.PI/2;
		camera2Cylinder1.position.set(0, 1.5, -1.5);
		//scene.add(camera2Cylinder1);
		
		camera2Cylinder2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 1), new THREE.MeshLambertMaterial({color: 0x666666}));
		 camera2Group.add(camera2Cylinder2);
		camera2Cylinder2.rotation.z = Math.PI/2;
		camera2Cylinder2.position.set(0, 1.5, -3.5);
		//scene.add(camera2Cylinder2);
		
		camera2Cylinder3 = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.5, 1), new THREE.MeshLambertMaterial({color: 0x777777}));
		 camera2Group.add(camera2Cylinder3);
		camera2Cylinder3.rotation.x = Math.PI/2;
		camera2Cylinder3.position.set(0, 0, 0);
		//scene.add(camera2Cylinder3);
		
		var axesCamera = new THREE.AxisHelper( 2 );
		camera2Group.add(axesCamera);
        //scene.add(axes);
		
		camera2Group.position.set(0, 90, 0);
		//camera2Group.rotation.x = Math.PI/2;
		camera2Group.lookAt(scene.position);
		scene.add(camera2Group);
		
		/////////////////////////////////////////////
		deBox = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), new THREE.MeshLambertMaterial({color: 0x133769}));
		deBox.visible = false;
		scene.add(deBox);
		
		//deBox1 = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), new THREE.MeshLambertMaterial({color: 0x133769}));
		//deBox1.position.set(0, 5, 10);
		//scene.add(deBox1);
		
		var camera3 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
		camera3.position.x = 0;
        camera3.position.y = 85;
        camera3.position.z = 0;
        camera3.lookAt(scene.position);
		camera3.rotation.z = -Math.PI;
		scene.add(camera3);
		var helper3 = new THREE.CameraHelper( camera3 );
		//scene.add( helper3 );
		
		///..........................................
		/////////////////////////////////////////////
//}	
		var arm = 0;
		var body = 0;
		var	base = 0;
		var currentCam = 1;
		var zoom = 50;
		
        var controls = new function() {
		
			this.animate = false;
			this.camera = "Perspective C1";
			this.helper = false;
			this.fieldOfView = 45;
			this.fov = 45;
			
			this.switchCamera = function() {
				currentCam +=1;
				if(currentCam > 3){ currentCam = 1;}
				if(currentCam == 1){ 
					controls.camera = "Perspective C1";
					camera.updateProjectionMatrix();
				} else if (currentCam == 2){
					controls.camera = "Dolly Zoom C2";
					camera2.updateProjectionMatrix()
				} else if (currentCam == 3){
					controls.camera = "Following C3";
					camera3.updateProjectionMatrix()
				}
            };
			
			this.updateC1 = function(){
				camera.fov = controls.fieldOfView;
				camera.updateProjectionMatrix();
				helper.update();
			}
			
			this.updateC2 = function(){
				if ( controls.helper == false ){
					helper2.visible = false;
				} else if ( controls.helper == true ){
					helper2.visible = true;
				}
				
				helper2.update();
			}
			
			this.updateDollyZoom = function(){
				camera2.fov = controls.fov;
				camera2.updateProjectionMatrix();
				//controls.zoom = ( 1 - (controls.fov/140) ) * 0 + (controls.fov/140) * 20;
				zoom = 40 / ( 2.0*Math.tan(0.5 * controls.fov * Math.PI/180) );
				helper2.update(); //window.innerWidth
				//console.log(controls.zoom);
			}
			
        }		
		var gui = new dat.GUI();
		gui.add(controls, 'animate');
		gui.add(controls, 'switchCamera');
		gui.add(controls, 'camera').listen();
		var c1Folder = gui.addFolder("Camera1");
		c1Folder.add(controls, 'fieldOfView', 30, 140).onChange(controls.updateC1);
		var c2Folder = gui.addFolder("Camera2");
		c2Folder.add(controls, 'helper').onChange(controls.updateC2);
		c2Folder.add(controls, 'fov', 10, 120).listen().onChange(controls.updateDollyZoom);
		//c2Folder.add(controls, 'zoom', 0, 30).listen().onChange(controls.updateDollyZoom);

        // call the render function
		render();
		
		var timing = 0;
		var r = 0;
		var phase = 1;
		var angle = 0;
		var Xpozicija = 0;
		var Ypozicija =0;
		var position = 0;
		var corner = 0;
		var speed = 0.1;
		function render() {

			if(controls.animate){
				
				Ypozicija =  Ypozicija +speed;
				if (Ypozicija < 18*10/2 )
				{
					speed = speed +0.01;
				}
//if(speed > 0)
				timing = Ypozicija/90;

				if (Ypozicija > 18*10/2 )
				{
					speed = speed -0.01;
				}




				body = Math.sin(timing)*(Math.PI/180)*90;
				angle = body * 90 / Math.PI;

//if(speed > 0)
		   		//timing = timing + speed/30;




					camera3.rotation.x = -Math.sin(timing*0.7)*(Math.PI/180)*75 - Math.PI/4;
					camera2Group.rotation.x = -Math.sin(timing*0.7)*(Math.PI/180)*75 - Math.PI/4+ Math.PI;
					console.log(timing);
					//r = (timing - Math.PI) / Math.PI * Math.PI;
					r = (40-angle)/60 * 1.5 * Math.PI;
					

					camera3.rotation.z = r + Math.PI*1.0;
					camera2Group.rotation.z = r ;

				scene.remove(bishop1);
				bishop(60, Xpozicija + (Xpoz*18), Ypozicija+(Ypoz*18), 0xffffff);
	

				camera3.updateProjectionMatrix();
				console.log(phase);
			}
			var dollyzoom = - zoom;
			
			camera2.position.x = dollyzoom;
			camera1Group.position.x = dollyzoom;
            
            var delta = clock.getDelta();
            trackballControls.update(delta);
			
            // render using requestAnimationFrame
            requestAnimationFrame(render);
			if(currentCam == 1){ 
				renderer.render(scene, camera);
			} else if (currentCam == 2){
				renderer.render(scene, camera2);
			} else if (currentCam == 3){
				renderer.render(scene, camera3);
			}
        }	
    });



</script>
</body>
</html>